diff --git a/config/index.md b/config/index.md
--- config/index.md
+++ config/index.md
@@ -74,9 +74,9 @@
     }
   } else {
     // command === 'build'
     return {
-      // configuration spécifique au mode build
+      // configuration spécifique au mode compilation
     }
   }
 })
 ```
@@ -132,9 +132,9 @@
 ### define

 - **Type :** `Record<string, string>`

-  Définit des constantes globales. Les valeurs saisies seront définies comme des variables globales en développement et remplacées statiquement pendant le build.
+  Définit des constantes globales. Les valeurs saisies seront définies comme des variables globales en développement et remplacées statiquement pendant la compilation.

   - Depuis la version `2.0.0-beta.70`, les chaînes de caractères sont utilisées comme des expressions brutes, donc si vous définissez une chaîne de caractères constante, elle doit être explicitement mise entre crochets (avec `JSON.stringify` par exemple).

   - Les remplacements sont faits seulement lorsque la correspondance est entourée par des délimiteurs de mots (`\b`).
@@ -165,9 +165,9 @@

 - **Type :** `string | false`
 - **Valeur par défaut :** `"public"`

-  Répertoire d’où servir les ressources statiques. Les fichiers de ce répertoires sont servis à `/` pendant le développement et copiés à la racine de `outDir` pendant le build, et ils sont toujours servis ou copiés tels quels sans aucune transformation. La valeur peut être soit un chemin absolu sur tout le système de fichiers, soit un chemin relatif à la racine du projet. La valeur par défaut est `.vite` quand aucun package.json n’est détecté.
+  Répertoire d’où servir les ressources statiques. Les fichiers de ce répertoires sont servis à `/` pendant le développement et copiés à la racine de `outDir` pendant la compilation, et ils sont toujours servis ou copiés tels quels sans aucune transformation. La valeur peut être soit un chemin absolu sur tout le système de fichiers, soit un chemin relatif à la racine du projet. La valeur par défaut est `.vite` quand aucun package.json n’est détecté.

   Définir `publicDir` à `false` désactive cette fonctionnalité.

   Voir [Le répertoire `public`](/guide/assets#le-repertoire-public) pour plus de détails.
@@ -195,9 +195,9 @@

   Si vous avez des duplications d’une même dépendance dans votre app (probablement à cause du hoisting ou de packages liés dans les monorepos), utilisez cette option pour forcer Vite à toujours résoudre les dépendances à la même copie (celle à la racine du projet).

   :::warning SSR + ESM
-  Pour les builds SSR, la déduplication ne fonctionne pas pour les builds ESM configurés via `build.rollupOptions.output`. Vous pouvez contourner cette limitation en utilisant des builds CJS en attendant qu’ESM propose un meilleur support des plugins pour le chargement de modules.
+  Pour les compilations SSR, la déduplication ne fonctionne pas pour la compilation en ESM configurée via `build.rollupOptions.output`. Vous pouvez contourner cette limitation en utilisant une compilation CJS en attendant qu’ESM propose un meilleur support des plugins pour le chargement de modules.
   :::

 ### resolve.conditions

@@ -656,9 +656,9 @@
     }
   })
   ```

-## Options du build
+## Options de compilation

 ### build.target

 - **Type :** `string | string[]`
@@ -673,18 +673,18 @@
   - Sinon, aucune transpilation ne sera effectuée.

   La transformation est réalisée à l’aide d’esbuild et la valeur doit être une [option target d’esbuild](https://esbuild.github.io/api/#target) valide. Les valeurs spécifiées peuvent être soit une version d’ECMAScript (par exemple `es2015`), une version de navigateur (par exemple `chrome58`), ou un array de plusieurs cibles comme celles-ci.

-  Notez que le build échouera s’il y a des fonctionnalités qui ne peuvent pas être transpilées par esbuild. Voir la [documentation d’esbuild](https://esbuild.github.io/content-types/#javascript) pour de plus amples détails.
+  Notez que la compilation échouera s’il y a des fonctionnalités qui ne peuvent pas être transpilées par esbuild. Voir la [documentation d’esbuild](https://esbuild.github.io/content-types/#javascript) pour de plus amples détails.

 ### build.polyfillModulePreload

 - **Type :** `boolean`
 - **Valeur par défaut :** `true`

   Définit si le [polyfill de module preload](https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill) doit être injecté automatiquement.

-  Si cette option est définie à `true`, le polyfill est automatiquement injecté au module proxy de chaque entrée `index.html`. Si le build est configuré pour utiliser une entrée spécifique non-HTML à l’aide de `build.rollupOptions.input`, alors il faut importer manuellement le polyfill dans ladite entrée :
+  Si cette option est définie à `true`, le polyfill est automatiquement injecté au module proxy de chaque entrée `index.html`. Si la compilation est configuré pour utiliser une entrée spécifique non-HTML à l’aide de `build.rollupOptions.input`, alors il faut importer manuellement le polyfill dans ladite entrée :

   ```js
   import 'vite/modulepreload-polyfill'
   ```
@@ -777,25 +777,25 @@
 - **Type :** `boolean`
 - **Valeur par défaut :** `false`
 - **Voir aussi :** [Intégration du back-end](/guide/backend-integration)

-  Quand cette option est à `true`, le build générera également un fichier `manifest.json` contenant un mapping entre les noms de fichiers de ressources non-hashés et leurs versions hashées, qui peut ensuite être utilisé par un framework serveur afin de rendre les bons liens de ressources.
+  Quand cette option est à `true`, la compilation générera également un fichier `manifest.json` contenant un mapping entre les noms de fichiers de ressources non-hashés et leurs versions hashées, qui peut ensuite être utilisé par un framework serveur afin de rendre les bons liens de ressources.

 ### build.ssrManifest

 - **Type :** `boolean`
 - **Valeur par défaut :** `false`
 - **Voir aussi :** [Rendu côté serveur (SSR)](/guide/ssr)

-  Quand cette option est à `true`, le build générera également un manifeste de rendu côté serveur permettant de déterminer les liens de style ainsi que les directives de pré-chargement (_preload directives_) des ressources en production.
+  Quand cette option est à `true`, la compilation générera également un manifeste de rendu côté serveur permettant de déterminer les liens de style ainsi que les directives de pré-chargement (_preload directives_) des ressources en production.

 ### build.ssr

 - **Type :** `boolean | string`
 - **Valeur par défaut :** `undefined`
 - **Voir aussi :** [Rendu côté serveur (SSR)](/guide/ssr)

-  Définit si le build doit être orienté vers un rendu côté serveur. La valeur peut être une chaîne spécifiant directement l’entrée de rendu côté serveur, ou `true`, ce qui requiert de spécifier l’entrée de rendu côté serveur à l’aide de `rollupOptions.input`.
+  Définit si la compilation doit être orienté vers un rendu côté serveur. La valeur peut être une chaîne spécifiant directement l’entrée de rendu côté serveur, ou `true`, ce qui requiert de spécifier l’entrée de rendu côté serveur à l’aide de `rollupOptions.input`.

 ### build.minify

 - **Type :** `boolean | 'terser' | 'esbuild'`
@@ -822,9 +822,9 @@

 - **Type :** `boolean`
 - **Valeur par défaut :** `true` si `outDir` est dans `root`

-  Par défaut, Vite videra le `outDir` lors du build s’il se trouve dans la racine projet. Il émettra un avertissement si `outDir` est en dehors de la racine projet pour empêcher de retirer accidentellement des fichiers importants. Vous pouvez définir explicitement cette option pour retirer l’avertissement. Elle est également disponible avec l’interface en ligne de commande en tant que `--emptyOutDir`.
+  Par défaut, Vite videra le `outDir` lors de la compilation s’il se trouve dans la racine projet. Il émettra un avertissement si `outDir` est en dehors de la racine projet pour empêcher de retirer accidentellement des fichiers importants. Vous pouvez définir explicitement cette option pour retirer l’avertissement. Elle est également disponible avec l’interface en ligne de commande en tant que `--emptyOutDir`.

 ### build.reportCompressedSize

 - **Type :** `boolean`
@@ -843,9 +843,9 @@

 - **Type :** [`WatcherOptions`](https://rollupjs.org/guide/en/#watch-options)`| null`
 - **Valeur par défaut :** `null`

-  Définissez cette option à `{}` pour activer le watcher de Rollup. Cette option est surtout utile dans des contextes où les plugins sont build-only ou pour les process d’intégration.
+  Définissez cette option à `{}` pour activer l'observateur de fichier de Rollup. Cette option est surtout utile dans des contextes où les plugins sont build-only ou pour les process d’intégration.

 ## Options de l’aperçu (_preview_)

 ### preview.host
@@ -990,9 +990,9 @@

 - **Type :** `'node' | 'webworker'`
 - **Valeur par défaut :** `node`

-  Environnement ciblé pour le build côté serveur.
+  Environnement ciblé pour la compilation côté serveur.

 ## Options du worker

 ### worker.format
diff --git a/index.md b/index.md
--- index.md
+++ index.md
@@ -8,17 +8,17 @@
 altActionLink: /guide/why

 features:
   - title: 💡 Démarrage instantané du serveur
-    details: Les fichiers sont servis instantanément sous la forme de modules ESM ! Il n’y a pas besoin de builder.
+    details: Les fichiers sont servis instantanément sous la forme de modules ESM ! Il n’y a pas besoin de compiler.
   - title: ⚡️ Rafraîchissement des modules ultra rapide
     details: Pendant le développement, les modules sont remplacés rapidement peu importe la taille de l’app.
   - title: 🛠️ Riche en fonctionnalités
     details: Support inclus pour Typescript, JSX, CSS, et bien d’autres.
-  - title: 📦 Build optimisé
-    details: Le build se fait grâce à Rollup, pré-configuré et avec le support du multi-page et du mode librairie.
+  - title: 📦 Compilation optimisée
+    details: La compilation se fait grâce à Rollup, pré-configuré et avec le support du multi-page et du mode librairie.
   - title: 🔩 Interface universelle de plugins
-    details: Interface de plugins basée sur Rollup et partagée entre développement et build.
+    details: Interface de plugins basée sur Rollup et partagée entre développement et compilation.
   - title: 🔑 APIs typées
     details: APIs programmatiques flexibles avec définition TypeScript de tous les types.
 footer: Licence MIT | Copyright © 2019-aujourd’hui Evan You & les contributeurs à Vite
 ---
diff --git a/README.md b/README.md
--- README.md
+++ README.md
@@ -6,9 +6,9 @@
 <br/>
 <p align="center">
   <a href="https://npmjs.com/package/vite"><img src="https://img.shields.io/npm/v/vite.svg" alt="npm package"></a>
   <a href="https://nodejs.org/en/about/releases/"><img src="https://img.shields.io/node/v/vite.svg" alt="node compatibility"></a>
-  <a href="https://github.com/vitejs/vite/actions/workflows/ci.yml"><img src="https://github.com/vitejs/vite/actions/workflows/ci.yml/badge.svg?branch=main" alt="build status"></a>
+  <a href="https://github.com/vitejs/vite/actions/workflows/ci.yml"><img src="https://github.com/vitejs/vite/actions/workflows/ci.yml/badge.svg?branch=main" alt="statut de compilation"></a>
   <a href="https://chat.vitejs.dev"><img src="https://img.shields.io/badge/chat-discord-blue?style=flat&logo=discord" alt="discord chat"></a>
 </p>
 <br/>

@@ -26,9 +26,9 @@
 Vite (prononcé comme en français) est un outil de compilation frontend d’un nouveau genre qui améliore grandement l’expérience de développement. Il se compose de deux parties :

 - Un serveur de développement qui sert les fichiers sous la forme de [modules ECMAScript](https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Modules), qui propose de [nombreuses fonctionnalités](https://vitejs.dev/guide/features.html) et qui permet un [rafraîchissement des modules (HMR)](https://vitejs.dev/guide/features.html#hot-module-replacement) très rapide.

-- Une [commande de build](https://vitejs.dev/guide/build.html) qui bundle votre code à l’aide de [Rollup](https://rollupjs.org), pré-configuré pour optimiser grandement la taille des ressources statiques en production.
+- Une [commande de compilation](https://vitejs.dev/guide/build.html) qui bundle votre code à l’aide de [Rollup](https://rollupjs.org), pré-configuré pour optimiser grandement la taille des ressources statiques en production.

 En plus, Vite peut être étendu grâce à son [API pour plugin](https://vitejs.dev/guide/api-plugin.html) ainsi que l’[API JavaScript](https://vitejs.dev/guide/api-javascript.html) typée.

 ## Contribution
diff --git a/.vitepress/config.js b/.vitepress/config.js
--- .vitepress/config.js
+++ .vitepress/config.js
@@ -110,9 +110,9 @@
               text: 'Gestion des ressources statiques',
               link: '/guide/assets'
             },
             {
-              text: 'Build de production',
+              text: 'Compilation de production',
               link: '/guide/build'
             },
             {
               text: 'Déployer un site statique',
diff --git a/blog/announcing-vite2.md b/blog/announcing-vite2.md
--- blog/announcing-vite2.md
+++ blog/announcing-vite2.md
@@ -9,9 +9,9 @@
 </p>

 Nous sommes très heureux d’annoncer aujourd’hui la sortie officielle de Vite 2.0 !

-Vite (du mot français) est un outil de build web front-end d’un nouveau genre. Vous pouvez le voir comme un combo entre un serveur de développement pré-configuré et un bundler, mais en plus léger et plus rapide. Il s’appuie sur le support des [modules ES natifs](https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Modules) de votre navigateur et sur des outils écrits dans des langages compilés comme [esbuild](https://esbuild.github.io/) pour fournir une expérience de développement vive et moderne.
+Vite (du mot français) est un outil de compilation web front-end d’un nouveau genre. Vous pouvez le voir comme un combo entre un serveur de développement pré-configuré et un bundler, mais en plus léger et plus rapide. Il s’appuie sur le support des [modules ES natifs](https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Modules) de votre navigateur et sur des outils écrits dans des langages compilés comme [esbuild](https://esbuild.github.io/) pour fournir une expérience de développement vive et moderne.

 Pour vous faire une idée d’à quel point Vite est rapide, regardez cette [comparaison vidéo](https://twitter.com/amasad/status/1355379680275128321) entre démarrer une application React sur Repl.it en utilisant Vite et en utilisant `create-react-app` (CRA).

 Si vous n’aviez jamais entendu parler de Vite jusqu’ici et que vous voudriez en savoir plus, nous avons une page expliquant les [raisons qui motivent le projet](https://vitejs.dev/guide/why.html). Si vous vous demandez en quoi Vite diffère des outils similaires, nous avons aussi une page de [comparaisons](https://vitejs.dev/guide/comparisons.html).
@@ -27,9 +27,9 @@
 Vite 2.0 capitalise sur ce que nous avons appris en cours de route et il a été complètement redesigné pour disposer d’une architecture interne plus robuste. Il est désormais entièrement indépendant du framework utilisé, et tout ce qui est spécifique aux frameworks est délégué aux plugins. Il y a maintenant des [templates officiels pour Vue, React, Preact, Lit Element](https://github.com/vitejs/vite/tree/main/packages/create-vite) et la communauté travaille en ce moment même à l’intégration de Svelte.

 ### Nouveau format de plugins et API

-Le nouveau système de plugins, inspiré par [WMR](https://github.com/preactjs/wmr), étend l’interface pour plugins de Rollup et est [compatible avec beaucoup de plugins Rollup](https://vite-rollup-plugins.patak.dev/) sans qu’il n’y ait besoin d’adaptations. Les plugins peuvent utiliser les hooks de Rollup, ainsi que des hooks et des propriétés supplémentaires spécifiques à Vite (par exemple pour différencier entre développement et build ou pour gérer différemment le rafraîchissement des modules à la volée).
+Le nouveau système de plugins, inspiré par [WMR](https://github.com/preactjs/wmr), étend l’interface pour plugins de Rollup et est [compatible avec beaucoup de plugins Rollup](https://vite-rollup-plugins.patak.dev/) sans qu’il n’y ait besoin d’adaptations. Les plugins peuvent utiliser les hooks de Rollup, ainsi que des hooks et des propriétés supplémentaires spécifiques à Vite (par exemple pour différencier entre développement et compilation ou pour gérer différemment le rafraîchissement des modules à la volée).

 L’[API programmatique](https://vitejs.dev/guide/api-javascript.html) a également été beaucoup améliorée pour faciliter l’apparition d’outils ou de frameworks de plus haut niveau par-dessus Vite.

 ### Pré-bundling des dépendances à l’aide d’esbuild
@@ -45,9 +45,9 @@
 - **Fractionnement (_code splitting_) du CSS** : un morceau (_chunk_) en JS émet également le CSS correspondant, qui sera automatiquement chargé en parallèle de ce dernier.

 ### Support du rendu côté serveur (_SSR_)

-Vite 2.0 est livré avec le [support expérimental du rendu côté serveur](https://vitejs.dev/guide/ssr.html). Vite fournit des APIs afin de charger et de mettre à jour efficacement le code source ESM en Node.js pendant le développement (presque comme du rafraîchissement de modules à la volée côté serveur), et externalise automatiquement les dépendances compatibles avec CommonJS pour accélérer la vitesse du build. Le serveur de production peut être complètement découplé de Vite, et le même setup peut être facilement adapté pour permettre le pré-rendu / la génération statique (_SSG_).
+Vite 2.0 est livré avec le [support expérimental du rendu côté serveur](https://vitejs.dev/guide/ssr.html). Vite fournit des APIs afin de charger et de mettre à jour efficacement le code source ESM en Node.js pendant le développement (presque comme du rafraîchissement de modules à la volée côté serveur), et externalise automatiquement les dépendances compatibles avec CommonJS pour accélérer la vitesse de la compilation. Le serveur de production peut être complètement découplé de Vite, et le même setup peut être facilement adapté pour permettre le pré-rendu / la génération statique (_SSG_).

 Le rendu côté serveur de Vite est proposé comme une fonctionnalité bas-niveau, et nous nous attendons à ce que des frameworks plus haut-niveau s’appuient dessus.

 ### Support sélectif des navigateurs plus anciens
diff --git a/guide/api-plugin.md b/guide/api-plugin.md
--- guide/api-plugin.md
+++ guide/api-plugin.md
@@ -1,7 +1,7 @@
 # API pour plugin

-Les plugins Vite étendent la très bonne interface pour plugin de Rollup avec quelques options spécifiques à Vite. L’intérêt est que vous pouvez créer un seul plugin et qu’il fonctionnera à la fois en développement et pour le build.
+Les plugins Vite étendent la très bonne interface pour plugin de Rollup avec quelques options spécifiques à Vite. L’intérêt est que vous pouvez créer un seul plugin et qu’il fonctionnera à la fois en développement et pour la compilation.

 **Il est recommandé de lire [la documentation des plugins Rollup](https://rollupjs.org/guide/en/#plugin-development) (en anglais) avant ce qui suit.**

 ## Créer un plugin
@@ -108,9 +108,9 @@
 Voir l’exemple de la [section suivante](#convention-pour-les-modules-virtuels).

 ## Convention pour les modules virtuels

-Les modules virtuels sont un procédé utile qui permet de passer des informations aux fichiers source au moment du build avec une syntaxe d’import de module ES normale.
+Les modules virtuels sont un procédé utile qui permet de passer des informations aux fichiers source au moment de la compilation avec une syntaxe d’import de module ES normale.

 ```js
 export default function myPlugin() {
   const virtualModuleId = '@my-virtual-module'
@@ -140,15 +140,15 @@

 console.log(msg)
 ```

-La convention de Vite pour les modules virtuels est de préfixer le chemin visible par l’utilisateur par `virtual:`. Si possible le nom du plugin devrait être utilisé comme un namespace pour éviter d’entrer en conflit avec les autres plugins de l’écosystème. Par exemple, `vite-plugin-posts` pourrait demander aux utilisateurs d’importer un module virtuel `virtual:posts` ou `virtual:posts/helpers` pour obtenir des informations au moment du build. En interne, les plugins qui utilisent des modules virtuels doivent préfixer l’identifiant par `\0` lorsqu’ils résolvent l’identifiant (c’est une convention de l’écosystème Rollup). Cela évite que d’autres plugins essayent de traiter le même identifiant (comme la résolution des nœuds), et les fonctionnalités intégrées à Vite comme les sourcemaps peuvent se servir de cette information pour différencier les modules virtuels des fichiers classiques. `\0` n’est pas un caractère autorisé dans les URLs d’import alors nous devons le remplacer pendant l’analyse de l’import. Dans le navigateur, un identifiant virtuel `\0{id}` sera encodé sous la forme `/@id/__x00__{id}` pour le développement. Cet identifiant sera à nouveau décodé avant d’entrer dans la pipeline de plugins, alors cette mécanique n’est pas visible par les hooks de plugins.
+La convention de Vite pour les modules virtuels est de préfixer le chemin visible par l’utilisateur par `virtual:`. Si possible le nom du plugin devrait être utilisé comme un namespace pour éviter d’entrer en conflit avec les autres plugins de l’écosystème. Par exemple, `vite-plugin-posts` pourrait demander aux utilisateurs d’importer un module virtuel `virtual:posts` ou `virtual:posts/helpers` pour obtenir des informations au moment de la compilation. En interne, les plugins qui utilisent des modules virtuels doivent préfixer l’identifiant par `\0` lorsqu’ils résolvent l’identifiant (c’est une convention de l’écosystème Rollup). Cela évite que d’autres plugins essayent de traiter le même identifiant (comme la résolution des nœuds), et les fonctionnalités intégrées à Vite comme les sourcemaps peuvent se servir de cette information pour différencier les modules virtuels des fichiers classiques. `\0` n’est pas un caractère autorisé dans les URLs d’import alors nous devons le remplacer pendant l’analyse de l’import. Dans le navigateur, un identifiant virtuel `\0{id}` sera encodé sous la forme `/@id/__x00__{id}` pour le développement. Cet identifiant sera à nouveau décodé avant d’entrer dans la pipeline de plugins, alors cette mécanique n’est pas visible par les hooks de plugins.

 Notez que les modules directement tirés d’un vrai fichier, comme c’est le cas d’un module de script dans un composant à fichier unique (_SFC_) (un composant à fichier unique .vue ou .svelte par exemple) n’ont pas besoin de suivre cette convention. Les composants à fichier unique génèrent en général une série de sous-modules lorsqu’ils sont traités mais le code de ceux-ci peut-être relié au système de fichiers. Utiliser `\0` pour ces sous-modules empêcherait les sourcemaps de fonctionner correctement.

 ## Hooks universels

-Pendant le développement, le serveur de Vite crée un conteneur de plugin qui invoque les [hooks de build de Rollup](https://rollupjs.org/guide/en/#build-hooks) de la même façon que le fait Rollup.
+Pendant le développement, le serveur de Vite crée un conteneur de plugin qui invoque les [hooks de compilation de Rollup](https://rollupjs.org/guide/en/#build-hooks) de la même façon que le fait Rollup.

 Les hooks suivants sont appelés une fois lors du démarrage du serveur :

 - [`options`](https://rollupjs.org/guide/en/#options)
@@ -302,16 +302,16 @@
     }
   }
   ```

-  Notez que `configureServer` n’est pas appelé au moment du build de production alors vos autres hooks doivent gérer le cas où l’instance de serveur est absente.
+  Notez que `configureServer` n’est pas appelé au moment de la compilation de production alors vos autres hooks doivent gérer le cas où l’instance de serveur est absente.

 ### `transformIndexHtml`

 - **Type :** `IndexHtmlTransformHook | { enforce?: 'pre' | 'post', transform: IndexHtmlTransformHook }`
 - **Genre :** `asynchrone`, `séquentiel`

-  Hook dédié au fait de transformer `index.html`. Le hook reçoit le HTML actuel sous la forme d’une chaîne de caractères et un contexte de transformation. Le contexte expose l’instance du [`ViteDevServer`](./api-javascript#vitedevserver) pendant le développement, et expose le bundle de sortie de Rollup pendant le build.
+  Hook dédié au fait de transformer `index.html`. Le hook reçoit le HTML actuel sous la forme d’une chaîne de caractères et un contexte de transformation. Le contexte expose l’instance du [`ViteDevServer`](./api-javascript#vitedevserver) pendant le développement, et expose le bundle de sortie de Rollup pendant la compilation.

   Le hook peut être asynchrone et retourne un des formats suivants :

   - Chaîne de caractères HTML transformée.
@@ -424,15 +424,15 @@
 - Alias.
 - Plugins utilisateur avec `enforce: 'pre'`.
 - Plugins internes à Vite.
 - Plugins utilisateur sans valeur pour enforce.
-- Plugins de build de Vite.
+- Plugins de compilation de Vite.
 - Plugins utilisateur avec `enforce: 'post'`.
-- Plugins de build finaux de Vite (minification, manifeste, reporting).
+- Plugins de compilation finaux de Vite (minification, manifeste, reporting).

 ## Application conditionnelle

-Par défaut les plugins sont invoqués à la fois pour serve et build. Dans les cas où un plugin ne doit être appliqué conditionnellement que pour serve ou build, utilisez la propriété `apply` pour seulement l’invoquer durant `'build'` ou `'serve'` :
+Par défaut les plugins sont invoqués à la fois pour `serve` et `build`. Dans les cas où un plugin ne doit être appliqué conditionnellement que pour serve ou `build`, utilisez la propriété `apply` pour seulement l’invoquer durant `'build'` ou `'serve'` :

 ```js
 function myPlugin() {
   return {
@@ -445,9 +445,9 @@
 Un fonction peut aussi être utilisée, pour plus de contrôle :

 ```js
 apply(config, { command }) {
-  // appliquer seulement pour le build et pas pour le rendu côté serveur
+  // appliquer seulement pour la compilation et pas pour le rendu côté serveur
   return command === 'build' && !config.build.ssr
 }
 ```

@@ -459,9 +459,9 @@

 - Il n’utilise pas le hook [`moduleParsed`](https://rollupjs.org/guide/en/#moduleparsed).
 - Sa phase de bundling et sa phase d’output sont découplées.

-Si un plugin Rollup n’a de sens que pour la phase de build, alors il peut être spécifié sous `build.rollupOptions.plugins`.
+Si un plugin Rollup n’a de sens que pour la phase de compilation, alors il peut être spécifié sous `build.rollupOptions.plugins`.

 Vous pouvez aussi agrémenter un plugin Rollup existant de propriétés propres à Vite :

 ```js
diff --git a/guide/assets.md b/guide/assets.md
--- guide/assets.md
+++ guide/assets.md
@@ -11,9 +11,9 @@
 import imgUrl from './img.png'
 document.getElementById('hero-img').src = imgUrl
 ```

-Par exemple, `imgUrl` sera `/img.png` pendant le développement, et deviendra `/assets/img.2d8efhg.png` pour le build de production.
+Par exemple, `imgUrl` sera `/img.png` pendant le développement, et deviendra `/assets/img.2d8efhg.png` pour la compilation de production.

 Le comportement est similaire au `file-loader` de webpack. La différence est que l’import peut utiliser au choix un chemin absolu (par rapport à la racine du projet pendant le développement) ou un chemin relatif.

 - Les références `url()` dans le CSS sont traitées de la même façon.
@@ -21,9 +21,9 @@
 - Si vous utilisez le plugin Vue, les références à des ressources dans le template d’un composant à fichier unique (_SFC_) sont convertis en imports.

 - Les types de fichiers les plus courants pour les images, les medias, ou les polices de caractères sont détectés automatiquement comme étant des ressources. Vous pouvez étendre la liste interne avec l’[option `assetsInclude`](/config/#assetsinclude).

-- Les ressources référencées sont incluses au graphe des ressources du build, se voient assigner un nom de fichier haché, et peuvent être transformées par des plugins d’optimisation.
+- Les ressources référencées sont incluses au graphe des ressources de compilation, se voient assigner un nom de fichier haché, et peuvent être transformées par des plugins d’optimisation.

 - Les ressources plus petites (en octets) que l’[option `assetsInlineLimit`](/config/#build-assetsinlinelimit) seront mises inline comme URLs de données base64.

 ### Imports URL explicites
@@ -47,9 +47,9 @@

 Les scripts peuvent être importés en tant que web workers à l’aide des suffixes `?worker` et `?sharedworker`.

 ```js
-// il sera inclut à un morceau (chunk) différent pour le build de production
+// il sera inclut à un morceau (chunk) différent pour la compilation de production
 import Worker from './shader.js?worker'
 const worker = new Worker()
 ```

@@ -73,9 +73,9 @@
 - qui ne sont jamais référencées dans le code source (par exemple `robots.txt`),
 - qui doivent garder exactement le même nom de fichier (sans hachage),
 - … ou tout simplement que vous ne voulez pas avoir à importer pour accéder à leur URL,

-alors vous pouvez les placer dans le répertoire spécial `public` à la racine de votre projet. Les ressources dans ce répertoire seront servies à la racine `/` pendant le développement, et copiées à la racine du répertoire dist telles quelles lors du build.
+alors vous pouvez les placer dans le répertoire spécial `public` à la racine de votre projet. Les ressources dans ce répertoire seront servies à la racine `/` pendant le développement, et copiées à la racine du répertoire `dist` telles quelles lors de la compilation.

 Le répertoire par défaut est `<racine>/public`, mais cela peut-être modifié à l’aide de l’[option `publicDir`](/config/#publicdir).

 Notez que :
@@ -102,9 +102,9 @@
   return new URL(`./dir/${name}.png`, import.meta.url).href
 }
 ```

-Pendant le build de production, Vite fera les transformations nécessaires pour que les URLs pointent toujours au bon endroit même après le bundling et le hachage des ressources.
+Pendant la compilation de production, Vite fera les transformations nécessaires pour que les URLs pointent toujours au bon endroit même après le bundling et le hachage des ressources.

 ::: warning Note : Ne fonctionne pas avec le rendu côté serveur (SSR)
 Ce pattern ne fonctionnera pas si vous utilisez Vite pour du rendu côté serveur, parce qu’`import.meta.url` a une sémantique différente dans le navigateur et dans Node.js. Le bundle serveur ne peut de toute façon pas déterminer l’URL cliente en amont.
 :::
diff --git a/guide/backend-integration.md b/guide/backend-integration.md
--- guide/backend-integration.md
+++ guide/backend-integration.md
@@ -5,9 +5,9 @@

 Si vous avez besoin d’une intégration particulière, vous pouvez suivre ce guide pour la configurer manuellement.
 :::

-1. Dans votre configuration Vite, configurez l’entrée et activez le manifeste de build :
+1. Dans votre configuration Vite, configurez l’entrée et activez le manifeste de compilation :

    ```js
    // vite.config.js
    export default defineConfig({
diff --git a/guide/build.md b/guide/build.md
--- guide/build.md
+++ guide/build.md
@@ -1,7 +1,7 @@
-# Build de production
+# Compilation de production

-Lorsqu’il est temps de déployer votre application en production, lancez simplement la commande `vite build`. Par défaut, elle utilise `<racine>/index.html` comme point d’entrée du build, et produit un bundle d’application qu’il est possible de servir avec un service d’hébergement statique. Vous pouvez retrouver des guides pour les services les plus populaires sur la page [Déployer un site statique](./static-deploy).
+Lorsqu’il est temps de déployer votre application en production, lancez simplement la commande `vite build`. Par défaut, elle utilise `<racine>/index.html` comme point d’entrée de compilation, et produit un bundle d’application qu’il est possible de servir avec un service d’hébergement statique. Vous pouvez retrouver des guides pour les services les plus populaires sur la page [Déployer un site statique](./static-deploy).

 ## Compatibilité navigateur

 Ce bundle de production part du principe que le JavaScript moderne est supporté. Par défaut, Vite cible les navigateurs qui supportent les [balises script de modules ES natifs](https://caniuse.com/es6-module) et les [imports dynamiques de modules ES natifs](https://caniuse.com/es6-module-dynamic-import). Pour référence, Vite utilise cette requête [browserslist](https://github.com/browserslist/browserslist) :
@@ -21,15 +21,15 @@
 - Voir aussi : [Gestion des ressources statiques](./assets)

 Si vous déployez votre projet sous un chemin public imbriqué, spécifiez l’[option de configuration `base`](/config/#base) et tous les chemins de ressources seront réécris en conséquence. Cette option peut aussi être spécifiée via l’interface en ligne de commande, par exemple `vite build --base=/mon/chemin/public/`.

-Les URLs de ressources importées par le JavaScript, les références `url()` dans le CSS, et les références à des ressources dans vos fichiers `.html` sont toutes ajustées automatiquement pour respecter cette option pendant le build.
+Les URLs de ressources importées par le JavaScript, les références `url()` dans le CSS, et les références à des ressources dans vos fichiers `.html` sont toutes ajustées automatiquement pour respecter cette option pendant la compilation.

-La seule exception est quand vous devez concaténer dynamiquement des URLs à la volée. Dans ce cas, utilisez la variable injectée globalement `import.meta.env.BASE_URL` qui contiendra le chemin public de base. Notez que cette variable est remplacée statiquement pendant le build alors elle doit apparaître telle quelle (par exemple `import.meta.env['BASE_URL']` ne fonctionnera pas).
+La seule exception est quand vous devez concaténer dynamiquement des URLs à la volée. Dans ce cas, utilisez la variable injectée globalement `import.meta.env.BASE_URL` qui contiendra le chemin public de base. Notez que cette variable est remplacée statiquement pendant la compilation alors elle doit apparaître telle quelle (par exemple `import.meta.env['BASE_URL']` ne fonctionnera pas).

-## Customiser le build
+## Customiser la compilation

-Le build peut être customisé à l’aide de ses diverses [options de configuration](/config/#options-du-build). Plus spécifiquement, vous pouvez ajuster les [options du Rollup](https://rollupjs.org/guide/en/#big-list-of-options) sous-jacent avec `build.rollupOptions` :
+La compilation peut être customisé à l’aide de ses diverses [options de configuration](/config/#options-de-compilation). Plus spécifiquement, vous pouvez ajuster les [options du Rollup](https://rollupjs.org/guide/en/#big-list-of-options) sous-jacent avec `build.rollupOptions` :

 ```js
 // vite.config.js
 module.exports = defineConfig({
@@ -40,11 +40,11 @@
   }
 })
 ```

-Par exemple, vous pouvez spécifier plusieurs sorties Rollup à l’aide de plugins qui ne sont appliqués que pour le build.
+Par exemple, vous pouvez spécifier plusieurs sorties Rollup à l’aide de plugins qui ne sont appliqués que pour la compilation.

-## Refaire le build lorsque les fichiers sont modifiés
+## Refaire la compilation lorsque les fichiers sont modifiés

 Vous pouvez activer le watcher Rollup avec `vite build --watch`. Ou alors vous pouvez directement ajuster les [`WatcherOptions`](https://rollupjs.org/guide/en/#watch-options) dans `build.watch` :

 ```js
@@ -73,9 +73,9 @@
 ```

 Pendant la développement, naviguez à `/nested/` — cela fonctionne comme attendu, du moins dans le contexte d’un serveur de fichiers statiques.

-Pour le build, tout ce que vous aurez à faire est de spécifier plusieurs fichiers `.html` comme points d’entrée :
+Pour la compilation, tout ce que vous aurez à faire est de spécifier plusieurs fichiers `.html` comme points d’entrée :

 ```js
 // vite.config.js
 const { resolve } = require('path')
@@ -119,9 +119,9 @@
       // bundle de votre librairie
       external: ['vue'],
       output: {
         // assurez-vous de fournir les variables globales à utiliser dans le
-        // build UMD pour les dépendances externalisées
+        // compilation UMD pour les dépendances externalisées
         globals: {
           vue: 'Vue'
         }
       }
diff --git a/guide/comparisons.md b/guide/comparisons.md
--- guide/comparisons.md
+++ guide/comparisons.md
@@ -3,15 +3,15 @@
 ## Snowpack

 [Snowpack](https://www.snowpack.dev/) est aussi un serveur de développement no-bundle reposant sur les bundles ES natifs qui est très similaire à Vite en termes de périmètre. En dehors des détails d’implémentation qui diffèrent, les deux projets ont beaucoup en commun en termes d’avantages techniques par rapport au tooling traditionnel. Le pré-bundling des dépendances de Vite est aussi inspiré de Snowpack v1 (qui est devenu [`esinstall`](https://github.com/snowpackjs/snowpack/tree/main/esinstall)). Les plus grosses différences entre les deux projets sont :

-**Build de production**
+**Compilation de production**

-La sortie de build par défaut de Snowpack n’est pas un bundle : il transforme chaque fichier en plusieurs modules buildés, qui peuvent ensuite être passés à différents « optimisateurs » (_"optimizers"_) qui s’occupent du bundling. L’intérêt est que vous pouvez choisir entre différents bundlers finaux pour répondre à des besoins spécifiques (par exemple, webpack, Rollup, et même esbuild), et le côté pervers est que l’expérience est relativement fragmentée — par exemple, l’optimisateur esbuild est toujours instable, l’optimisateur Rollup n’est pas maintenu officiellement, et différents optimisateurs ne rendent pas la même chose en sortie et ne sont pas configurés de la même façon.
+La sortie de compilation par défaut de Snowpack n’est pas un bundle : il transforme chaque fichier en plusieurs modules compilatés, qui peuvent ensuite être passés à différents « optimisateurs » (_"optimizers"_) qui s’occupent du bundling. L’intérêt est que vous pouvez choisir entre différents bundlers finaux pour répondre à des besoins spécifiques (par exemple, webpack, Rollup, et même esbuild), et le côté pervers est que l’expérience est relativement fragmentée — par exemple, l’optimisateur esbuild est toujours instable, l’optimisateur Rollup n’est pas maintenu officiellement, et différents optimisateurs ne rendent pas la même chose en sortie et ne sont pas configurés de la même façon.

-Vite choisit d’avoir une intégration plus poussée d’un seul bundler (Rollup) afin de fournir une expérience plus structurée. Cela permet aussi à Vite de proposer une [API universelle pour plugin](./api-plugin) qui fonctionne à la fois pour le développement et pour le build.
+Vite choisit d’avoir une intégration plus poussée d’un seul bundler (Rollup) afin de fournir une expérience plus structurée. Cela permet aussi à Vite de proposer une [API universelle pour plugin](./api-plugin) qui fonctionne à la fois pour le développement et pour la compilation.

-Grâce au process de build plus intégré, Vite supporte quelques fonctionnalités qui ne sont pour l’instant pas disponibles avec les optimisateurs de build de Snowpack :
+Grâce au process de compilation plus intégré, Vite supporte quelques fonctionnalités qui ne sont pour l’instant pas disponibles avec les optimisateurs de compilation de Snowpack :

 - [Support du multi-pages](./build#application-multi-pages)
 - [Mode librairie](./build#mode-librairie)
 - [Fractionnement (_code splitting_) automatique du CSS](./features#fractionnement-code-splitting-du-css)
@@ -43,7 +43,7 @@
 ## @web/dev-server

 [@web/dev-server](https://modern-web.dev/docs/dev-server/overview/) (autrefois `es-dev-server`) est un bon projet et le serveur basé sur Koa de Vite 1.0 en est inspiré.

-`@web/dev-server` est un peu plus bas-niveau en termes de périmètre. Il ne fournit pas d’intégrations officielles pour les frameworks, et requiert de configurer manuellement Rollup pour le build de production.
+`@web/dev-server` est un peu plus bas-niveau en termes de périmètre. Il ne fournit pas d’intégrations officielles pour les frameworks, et requiert de configurer manuellement Rollup pour la compilation de production.

 De manière générale, Vite est un outil plus _opinionated_ / haut-niveau et vise à fournir des comportements par défaut qui conviennent la plupart du temps. Ceci étant dit, le projet `@web` contient beaucoup d’autres outils qui sont excellents et qui peuvent aussi être utiles pour les utilisateurs de Vite.
diff --git a/guide/dep-pre-bundling.md b/guide/dep-pre-bundling.md
--- guide/dep-pre-bundling.md
+++ guide/dep-pre-bundling.md
@@ -25,9 +25,9 @@
    ```

 2. **La performance :** Vite convertit les dépendances ESM ayant beaucoup de modules internes en un module unique pour améliorer la performance de chargement.

-   Certains packages fournissent leurs builds en modules ES sous la forme de plein de fichiers différents qui s’importent les uns les autres. Par exemple, [`lodash-es` a plus de 600 modules internes](https://unpkg.com/browse/lodash-es/) ! Lorsque l’on écrit `import { debounce } from 'lodash-es'`, le navigateur doit effectuer plus de 600 requêtes HTTP en même temps ! Même si le serveur peut les supporter, le grand nombre de requêtes crée un embouteillage du côté du navigateur, ce qui rend le chargement de la page nettement plus lent.
+   Certains packages fournissent leurs modules compilés sous format ES en plein de fichiers différents qui s’importent les uns les autres. Par exemple, [`lodash-es` a plus de 600 modules internes](https://unpkg.com/browse/lodash-es/) ! Lorsque l’on écrit `import { debounce } from 'lodash-es'`, le navigateur doit effectuer plus de 600 requêtes HTTP en même temps ! Même si le serveur peut les supporter, le grand nombre de requêtes crée un embouteillage du côté du navigateur, ce qui rend le chargement de la page nettement plus lent.

    En pré-bundlant `lodash-es` en un unique module, il n’y a plus besoin que d’une requête HTTP !

 ## Découverte automatique des dépendances
@@ -40,10 +40,10 @@

 Dans une configuration monorepo, une dépendance peut être un package lié du même dépôt. Vite détecte automatiquement les dépendances qui ne sont pas résolues depuis `node_modules` et les traite comme du code source. Il n’essaiera pas de bundler la dépendance liée, et analysera sa liste de dépendances à la place.

 ::: warning Note
-Les dépendances liées peuvent ne pas fonctionner correctement dans le build final à cause de différences dans la façon de résoudre les dépendances.
-Utilisez plutôt `npm package` pour toutes les dépendances locales pour éviter d’avoir des problèmes dans le build final.
+Les dépendances liées peuvent ne pas fonctionner correctement dans la compilation final à cause de différences dans la façon de résoudre les dépendances.
+Utilisez plutôt `npm package` pour toutes les dépendances locales pour éviter d’avoir des problèmes dans la compilation finale.
 :::

 ## Modifier le comportement

diff --git a/guide/env-and-mode.md b/guide/env-and-mode.md
--- guide/env-and-mode.md
+++ guide/env-and-mode.md
@@ -95,9 +95,9 @@
 Dans votre application, vous pouvez rendre le titre en utilisant `import.meta.env.VITE_APP_TITLE`.

 Cependant, il est important de comprendre que le **mode** est un concept plus large que simplement développement ou production. Un exemple typique est que vous pourriez vouloir disposer d’un mode « staging » qui aurait un comportement similaire à la production, mais avec des variables d’environnement légèrement différentes de celle-ci.

-Vous pouvez surcharger le mode utilisé par défaut pour une commande en passant l’option `--mode` en ligne de commande. Par exemple, si vous souhaitez builder votre app pour notre mode staging hypothétique :
+Vous pouvez surcharger le mode utilisé par défaut pour une commande en passant l’option `--mode` en ligne de commande. Par exemple, si vous souhaitez compiler votre app pour notre mode staging hypothétique :

 ```bash
 vite build --mode staging
 ```
diff --git a/guide/features.md b/guide/features.md
--- guide/features.md
+++ guide/features.md
@@ -29,9 +29,9 @@
 ## TypeScript

 Vite supporte l’import de fichiers `.ts` par défaut.

-Vite ne fait que transpiler les fichiers `.ts` et n’effectue **AUCUNE** vérification des types (_type checking_). Il part du principe que c’est votre IDE et votre process de build qui prennent en charge la vérification des types (vous pouvez lancer `tsc --noEmit` dans le script de build ou installer `vue-tsc` et lancer `vue-tsc --noEmit` pour effectuer la vérification des types de vos fichiers `*.vue`).
+Vite ne fait que transpiler les fichiers `.ts` et n’effectue **AUCUNE** vérification des types (_type checking_). Il part du principe que c’est votre IDE et votre process de compilation qui prennent en charge la vérification des types (vous pouvez lancer `tsc --noEmit` dans le script de compilation ou installer `vue-tsc` et lancer `vue-tsc --noEmit` pour effectuer la vérification des types de vos fichiers `*.vue`).

 Vite utilise [esbuild](https://github.com/evanw/esbuild) pour transpiler le TypeScript en JavaScript, ce qui est environ 20 à 30 fois plus rapide qu’avec `tsc`, et les remplacements de modules peuvent être faits en moins de 50 ms.

 Utilisez la syntaxe d’[imports et d’export des types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export) pour éviter d’éventuels problèmes comme les imports de types qui seraient mal bundlés. Par exemple :
@@ -65,9 +65,9 @@
 La plupart des librairies présument que `"useDefineForClassFields": true`, comme [MobX](https://mobx.js.org/installation.html#use-spec-compliant-transpilation-for-class-properties) par exemple, ou [Vue Class Components 8.x](https://github.com/vuejs/vue-class-component/issues/465).

 Mais certaines d’entre elles n’ont pas encore fait la transition, comme [`lit-element`](https://github.com/lit/lit-element/issues/1030). Définissez explicitement `useDefineForClassFields` à `false` dans ces cas-là.

-#### Autres options du compilateur qui affectent le résultat du build
+#### Autres options du compilateur qui affectent le résultat de la compilation

 - [`extends`](https://www.typescriptlang.org/tsconfig#extends)
 - [`importsNotUsedAsValues`](https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues)
 - [`preserveValueImports`](https://www.typescriptlang.org/tsconfig#preserveValueImports)
@@ -235,9 +235,9 @@
 ```

 ```js
 // charge un web worker qui est mis inline en chaîne de caractères base64 au
-// moment du build
+// moment de la compilation
 import InlineWorker from './worker.js?worker&inline'
 ```

 Plus de détails sur la page [Gestion des ressources statiques](./assets).
@@ -281,9 +281,9 @@
   })
 }
 ```

-Les fichiers correspondants sont chargés de manière opportune (_lazy loaded_) à l’aide de l’import dynamique et seront séparés en différents morceaux (_chunks_) durant le build. Si vous préférez importer tous les modules directement (par exemple si vous avez besoin que des effets secondaires (_side-effects_) de ces modules soient d’abord appliqués), vous pouvez utiliser plutôt `import.meta.globEager` :
+Les fichiers correspondants sont chargés de manière opportune (_lazy loaded_) à l’aide de l’import dynamique et seront séparés en différents morceaux (_chunks_) durant la compilation. Si vous préférez importer tous les modules directement (par exemple si vous avez besoin que des effets secondaires (_side-effects_) de ces modules soient d’abord appliqués), vous pouvez utiliser plutôt `import.meta.globEager` :

 ```js
 const modules = import.meta.globEager('./dir/*.js')
 ```
@@ -333,9 +333,9 @@
   /* ... */
 })
 ```

-Dans le build de production, les fichiers `.wasm` qui sont plus petits que `assetInlineLimit` seront mis inline en tant que chaînes de caractères base64. Sinon, ils seront copiés dans le dossier dist comme des ressources et seront récupérés à la demande.
+Dans la compilation de production, les fichiers `.wasm` qui sont plus petits que `assetInlineLimit` seront mis inline en tant que chaînes de caractères base64. Sinon, ils seront copiés dans le dossier dist comme des ressources et seront récupérés à la demande.

 ## Web workers

 Un script web worker peut être importé directement en suffixant `?worker` ou `?sharedworker` à la requête d’import. Par défaut, l’export sera un constructeur de worker :
@@ -345,19 +345,19 @@

 const worker = new MyWorker()
 ```

-Le script de worker peut aussi être une déclaration `import` plutôt qu’`importScripts()` — notez que durant le développement cela repose sur le support natif et ne fonctionne actuellement qu’avec Chrome, mais pour le build de production il sera compilé.
+Le script de worker peut aussi être une déclaration `import` plutôt qu’`importScripts()` — notez que durant le développement cela repose sur le support natif et ne fonctionne actuellement qu’avec Chrome, mais pour la compilation de production il sera compilé.

-Par défaut, le script du worker sera émis dans un morceau (_chunk_) différent dans le build de production. Si vous souhaitez mettre le worker inline dans des chaînes de caractères base64, ajoutez l’instruction `inline` :
+Par défaut, le script du worker sera émis dans un morceau (_chunk_) différent dans la compilation de production. Si vous souhaitez mettre le worker inline dans des chaînes de caractères base64, ajoutez l’instruction `inline` :

 ```js
 import MyWorker from './worker?worker&inline'
 ```

-## Optimisations du build
+## Optimisations de la compilation

-> Les fonctionnalités ci-dessous sont appliquées automatiquement lors du process de build et il n’y a pas besoin de les configurer explicitement, à moins que vous ne vouliez les désactiver.
+> Les fonctionnalités ci-dessous sont appliquées automatiquement lors du process de compilation et il n’y a pas besoin de les configurer explicitement, à moins que vous ne vouliez les désactiver.

 ### Fractionnement (_code splitting_) du CSS

 Vite extrait automatiquement le CSS utilisé par les modules dans un morceau (_chunk_) asynchrone et génère un fichier séparé. Le fichier CSS est automatiquement chargé via une balise `<link>` quand le morceau asynchrone associé est chargé, et le morceau asynchrone n’est évalué qu’après le chargement du CSS pour éviter les [FOUCs](https://fr.wikipedia.org/wiki/FOUC).
diff --git a/guide/index.md b/guide/index.md
--- guide/index.md
+++ guide/index.md
@@ -5,25 +5,25 @@
 </audio>

 ## Vue d’ensemble

-Vite (prononcé comme en français<button style="border:none;padding:3px;border-radius:4px" id="play-vite-audio" onclick="document.getElementById('vite-audio').play();"><img src="/voice.svg" height="15"></button>) est un outil de build qui vise à proposer une expérience de développement plus rapide et légère pour les projets web modernes. Il se découpe en deux grandes parties :
+Vite (prononcé comme en français<button style="border:none;padding:3px;border-radius:4px" id="play-vite-audio" onclick="document.getElementById('vite-audio').play();"><img src="/voice.svg" height="15"></button>) est un outil de compilation qui vise à proposer une expérience de développement plus rapide et légère pour les projets web modernes. Il se découpe en deux grandes parties :

 - Un serveur de développement qui propose de [nombreuses fonctionnalités](./features) à travers les [modules ES natifs](https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Modules), y compris un [rafraîchissement des modules à la volée (_HMR_)](./features#rafraichissement-des-modules-a-la-volee-hmr) ultra rapide.

-- Une commande de build qui bundle votre code à l’aide de [Rollup](https://rollupjs.org), qui est pré-configuré pour optimiser grandement la taille des ressources statiques en production.
+- Une commande de compilation qui bundle votre code à l’aide de [Rollup](https://rollupjs.org), qui est pré-configuré pour optimiser grandement la taille des ressources statiques en production.

 Vite est « _opinionated_ » et propose certains comportements par défaut qui conviendront dans la plupart des cas, et il est aussi possible de l’étendre grâce à son [API pour plugin](./api-plugin) et son [API JavaScript](./api-javascript).

 Vous pouvez en apprendre plus sur les raisons qui motivent le projet sur la page [Pourquoi utiliser Vite ?](./why).

 ## Support navigateur

-- La configuration par défaut cible les navigateurs qui supportent à la fois les [modules ES natifs à travers les balises script](https://caniuse.com/es6-module) et l’[import dynamique de modules ES natifs](https://caniuse.com/es6-module-dynamic-import). Les navigateurs antérieurs peuvent être supportés à l’aide du plugin officiel [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy) — voir la page [Build de production](./build) pour plus de détails.
+- La configuration par défaut cible les navigateurs qui supportent à la fois les [modules ES natifs à travers les balises script](https://caniuse.com/es6-module) et l’[import dynamique de modules ES natifs](https://caniuse.com/es6-module-dynamic-import). Les navigateurs antérieurs peuvent être supportés à l’aide du plugin officiel [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy) — voir la page [Compilation de production](./build) pour plus de détails.

 ## Essayer Vite en ligne

-Vous pouvez essayer Vite en ligne sur [StackBlitz](https://vite.new/). Le site exécute une configuration de build basée sur Vite directement dans le navigateur, alors l’expérience est quasiment la même qu’en local, sans avoir besoin d’installer quoi que ce soit sur votre machine. Vous pouvez naviguer sur `vite.new/{template}` pour utiliser un framework.
+Vous pouvez essayer Vite en ligne sur [StackBlitz](https://vite.new/). Le site exécute une configuration de compilation basée sur Vite directement dans le navigateur, alors l’expérience est quasiment la même qu’en local, sans avoir besoin d’installer quoi que ce soit sur votre machine. Vous pouvez naviguer sur `vite.new/{template}` pour utiliser un framework.

 Les templates supportés sont :

 |             JavaScript              |                TypeScript                 |
@@ -120,19 +120,19 @@
 {
   "scripts": {
     "dev": "vite", // démarre le serveur de développement
                    // alias : `vite dev`, `vite serve`
-    "build": "vite build",    // effectue le build de production
-    "preview": "vite preview" // prévisualise le build de production en local
+    "build": "vite build",    // effectue la compilation de production
+    "preview": "vite preview" // prévisualise la compilation de production en local
   }
 }
 ```

 Des options de ligne de commande supplémentaires comme `--port` ou `--https` sont disponibles. Vous pouvez en voir la liste en lançant `npx vite --help` dans votre projet.

 ## Utiliser des commits inédits

-Si vous voulez tester les dernières fonctionnalités sans attendre de nouvelle version, vous devrez cloner le [dépôt vite](https://github.com/vitejs/vite) sur votre machine, le builder et le lier (_link_) vous-même ([pnpm](https://pnpm.io/) doit être installé) :
+Si vous voulez tester les dernières fonctionnalités sans attendre de nouvelle version, vous devrez cloner le [dépôt vite](https://github.com/vitejs/vite) sur votre machine, le compiler et le lier (_link_) vous-même ([pnpm](https://pnpm.io/) doit être installé) :

 ```bash
 git clone https://github.com/vitejs/vite.git
 cd vite
diff --git a/guide/migration.md b/guide/migration.md
--- guide/migration.md
+++ guide/migration.md
@@ -11,9 +11,9 @@
 - `jsx` et `enableEsbuild` ont été retirées ; utilisez plutôt la nouvelle [option `esbuild`](/config/#esbuild).

 - Les [options en lien avec le CSS](/config/#css-modules) sont désormais regroupées sous `css`.

-- Toutes les [options spécifiques au build](/config/#options-du-build) sont désormais regroupées sous `build`.
+- Toutes les [options spécifiques à la compilation](/config/#options-de-compilation) sont désormais regroupées sous `build`.

   - `rollupInputOptions` et `rollupOutputOptions` sont remplacées par [`build.rollupOptions`](/config/#build-rollupoptions).
   - `esbuildTarget` est désormais [`build.target`](/config/#build-target).
   - `emitManifest` est désormais [`build.manifest`](/config/#build-manifest).
@@ -97,9 +97,9 @@
 `import.meta.hot.acceptDeps()` est désormais déprécié. [`import.meta.hot.accept()`](./api-hmr#hot-accept-deps-cb) accepte désormais une ou plusieurs dépendances.

 ## Changements du format du manifeste

-Le manifeste du build utilise désormais le format suivant :
+Le manifeste de compilation utilise désormais le format suivant :

 ```json
 {
   "index.js": {
diff --git a/guide/ssr.md b/guide/ssr.md
--- guide/ssr.md
+++ guide/ssr.md
@@ -153,14 +153,14 @@
 +   "dev": "node server"
   }
 ```

-## Build de production
+## Compilation de production

 Pour mettre en production un projet usant du rendu côté serveur, on doit :

-1. Produire un build client normal, et
-2. Produire un build de rendu côté serveur, qui peut être chargé directement par `require()` afin que l’on n’ait pas besoin de repasser dans le `ssrLoadModule` de Vite.
+1. Produire une compilation client normal, et
+2. Produire une compilation de rendu côté serveur, qui peut être chargé directement par `require()` afin que l’on n’ait pas besoin de repasser dans le `ssrLoadModule` de Vite.

 Les scripts de `package.json` ressembleront à ça :

 ```json
@@ -172,30 +172,30 @@
   }
 }
 ```

-Notez que le signal `--ssr` indique qu’il s’agit d’un build de rendu côté serveur. Il devrait également indiquer l’entrée de rendu côté serveur.
+Notez que le signal `--ssr` indique qu’il s’agit d’une compilation de rendu côté serveur. Il devrait également indiquer l’entrée de rendu côté serveur.

 Ensuite, dans `server.js`, on doit ajouter de la logique spécifique à la production en se référant à `process.env.NODE_ENV` :

-- Au lieu de lire le `index.html` racine, utilisez plutôt `dist/client/index.html` comme template, puisqu’il contient les bons liens vers les ressources pour le build client.
+- Au lieu de lire le `index.html` racine, utilisez plutôt `dist/client/index.html` comme template, puisqu’il contient les bons liens vers les ressources pour la compilation client.

-- Au lieu d’`await vite.ssrLoadModule('/src/entry-server.js')`, utilisez plutôt `require('./dist/server/entry-server.js')` (ce fichier est le résultat du build de rendu côté serveur).
+- Au lieu d’`await vite.ssrLoadModule('/src/entry-server.js')`, utilisez plutôt `require('./dist/server/entry-server.js')` (ce fichier est le résultat de la compilation de rendu côté serveur).

 - Déplacez la création et tous les usages du serveur du développement `vite` derrière des branches conditionnelles spécifiques au développement, et ajoutez des middlewares servant les fichiers statiques de `dist/client`.

 Référez-vous aux démonstrations pour [Vue](https://github.com/vitejs/vite/tree/main/packages/playground/ssr-vue) et [React](https://github.com/vitejs/vite/tree/main/packages/playground/ssr-react) si vous avez besoin d’un exemple de configuration qui fonctionne.

 ## Générer les directives de pré-chargement (_preload directives_)

-`vite build` supporte le signal `--ssrManifest` qui générera un fichier `ssr-manifest.json` dans le répertoire de sortie du build :
+`vite build` supporte le signal `--ssrManifest` qui générera un fichier `ssr-manifest.json` dans le répertoire de sortie de la compilation:

 ```diff
 - "build:client": "vite build --outDir dist/client",
 + "build:client": "vite build --outDir dist/client --ssrManifest",
 ```

-Le script ci-dessus générera désormais un fichier `dist/client/ssr-manifest.json` pour le build client — oui, le manifeste de rendu côté serveur est généré depuis le build client car nous voulons associer les identifiants de modules aux fichiers clients. Le manifeste contient des associations entre les identifiants de modules et les morceaux (_chunks_) ou les fichiers de ressources correspondants.
+Le script ci-dessus générera désormais un fichier `dist/client/ssr-manifest.json` pour la compilation client — oui, le manifeste de rendu côté serveur est généré depuis la compilation client car nous voulons associer les identifiants de modules aux fichiers clients. Le manifeste contient des associations entre les identifiants de modules et les morceaux (_chunks_) ou les fichiers de ressources correspondants.

 Pour exploiter le manifeste, les frameworks doivent fournir un moyen de collecter les identifiants des modules des composants qui ont été utilisés durant le rendu côté serveur.

 `@vitejs/plugin-vue` intègre ce processus et inscrit automatiquement les identifiants des modules utilisés pour les composants sur le contexte de rendu côté serveur de Vue associé :
@@ -215,19 +215,19 @@
 Si les routes et les données requises pour certaines routes sont connues à l’avance, on peut pré-rendre ces routes en HTML statique en usant de la même logique que pour le rendu côté serveur de production. Cela peut-être considéré comme une forme de génération côté serveur. Voir [le script de pré-rendu de démonstration](https://github.com/vitejs/vite/blob/main/packages/playground/ssr-vue/prerender.js) pour un exemple qui fonctionne.

 ## Externalisation

-De nombreuses dépendances fournissent à la fois des fichiers de modules ES et CommonJS. Une dépendance fournissant un build CommonJS peut être « externalisée » de la transformation et du système de modules de rendu côté serveur de Vite lorsque le rendu côté serveur est utilisé, afin de rendre à la fois le serveur de développement et le build plus rapides. Par exemple, plutôte que de tirer la version modules ES de React et d’ensuite la re-transformer pour qu’elle soit compatible avec Node.js, il est plus efficace de simplement `require('react')`. Cela raccourcit aussi grandement la durée du build de rendu côté serveur.
+De nombreuses dépendances fournissent à la fois des fichiers de modules ES et CommonJS. Une dépendance fournissant une compilation CommonJS peut être « externalisée » de la transformation et du système de modules de rendu côté serveur de Vite lorsque le rendu côté serveur est utilisé, afin de rendre à la fois le serveur de développement et la compilation plus rapides. Par exemple, plutôte que de tirer la version modules ES de React et d’ensuite la re-transformer pour qu’elle soit compatible avec Node.js, il est plus efficace de simplement `require('react')`. Cela raccourcit aussi grandement la durée de compilation de rendu côté serveur.

 Vite réalise l’externalisation du rendu côté serveur automatiquement selon les heuristiques suivantes :

-- Si le point d’entrée de module ES résolu et son point d’entrée par défaut pour Node sont différents, le point d’entrée pour Node est probablement un build CommonJS qui peut être externalisé. Par exemple, `vue` sera externalisé automatiquement car il fournit à la fois un build module ES et un build CommonJS.
+- Si le point d’entrée de module ES résolu et son point d’entrée par défaut pour Node sont différents, le point d’entrée pour Node est probablement une compilation CommonJS qui peut être externalisé. Par exemple, `vue` sera externalisé automatiquement car il fournit à la fois une compilation en module ES et une compilation en CommonJS.

 - Sinon, Vite regardera si le point d’entrée du package contient de la syntaxe de modules ES valide — si ce n’est pas le cas, le package est probablement au format CommonJS et sera externalisé. Par exemple, `react-dom` sera externalisé automatiquement car il ne spécifie qu’une entrée et qu’elle est au format CommonJS.

 Si les heuristiques mènent à des erreurs, vous pouvez ajuster manuellement l’externalisation du rendu côté serveur à l’aide des options de configuration `ssr.external` et `ssr.noExternal`.

-Dans le futur, ces heuristiques seront sans doute meilleures si le projet a le `type: "module"` d’activé, afin que Vite puisse aussi externaliser les dépendances qui fournissent des builds ESM compatibles avec Node en les important avec `import()` pendant le rendu côté serveur.
+Dans le futur, ces heuristiques seront sans doute meilleures si le projet a le `type: "module"` d’activé, afin que Vite puisse aussi externaliser les dépendances qui fournissent des compilation ESM compatibles avec Node en les important avec `import()` pendant le rendu côté serveur.

 :::warning Gérer les alias
 Si vous avez configuré des alias qui redirigent un package vers un autre, vous pourriez plutôt vouloir faire des alias des véritables packages `node_modules` afin que cela fonctionne pour les dépendances externalisées pour le rendu côté serveur. [Yarn](https://classic.yarnpkg.com/en/docs/cli/add/#toc-yarn-add-alias) et [pnpm](https://pnpm.js.org/en/aliases) supportent tous deux les alias via le préfixe `npm:`.
 :::
@@ -262,12 +262,12 @@
 :::

 ## Cible de rendu côté serveur

-La cible par défaut du build de rendu côté serveur est un environnement Node, mais vous pouvez également exécuter le serveur dans un web worker. La différence réside dans la résolution de l’entrée du package qui est différente suivant la plateforme. Vous pouvez configurer la cible pour qu’elle soit un web worker en définissant `ssr.target` sur `'webworker'`.
+La cible par défaut de compilation de rendu côté serveur est un environnement Node, mais vous pouvez également exécuter le serveur dans un web worker. La différence réside dans la résolution de l’entrée du package qui est différente suivant la plateforme. Vous pouvez configurer la cible pour qu’elle soit un web worker en définissant `ssr.target` sur `'webworker'`.

 ## Bundle de rendu côté serveur

-Dans certains cas, comme lorsque le runtime est `webworker`, il se peut que vous souhaitiez que votre build de rendu côté serveur soit bundlé en un seul fichier JavaScript. Vous pouvez obtenir ce comportement en définissant `ssr.noExternal` à `true`. Cela aura deux effets :
+Dans certains cas, comme lorsque le runtime est `webworker`, il se peut que vous souhaitiez que votre compilation de rendu côté serveur soit bundlé en un seul fichier JavaScript. Vous pouvez obtenir ce comportement en définissant `ssr.noExternal` à `true`. Cela aura deux effets :

 - Toutes les dépendances seront traitées comme `noExternal`
 - Une erreur sera déclenchée si une fonctionnalité intégrée à Node.js est importée
diff --git a/guide/static-deploy.md b/guide/static-deploy.md
--- guide/static-deploy.md
+++ guide/static-deploy.md
@@ -14,34 +14,34 @@
   }
 }
 ```

-Il est important de noter que `vite preview` est fait pour prévisualiser le build localement et pas pour être un serveur de production.
+Il est important de noter que `vite preview` est fait pour prévisualiser la compilation localement et pas pour être un serveur de production.

 ::: tip NOTE
 Ces guides fournissent des instructions pour effectuer un déploiement statique de votre site Vite. Vite propose également un support expérimental du rendu côté serveur (_server side rendering_). Le rendu côté serveur fait référence aux frameworks front-end qui supportent le fait d’exécuter une application dans Node.js, qui font un pré-rendu en HTML, et qui l’« hydratent » côté client en bout de course. Allez voir le [guide du rendu côté serveur](./ssr) pour en savoir plus sur cette fonctionnalité. Autrement, si vous souhaitez intégrer votre application à un framework côté serveur classique, allez plutôt voir le [guide d’intégration du back-end](./backend-integration).
 :::

-## Builder l’application
+## Compiler l’application

-Vous pouvez lancer la commande `npm run build` pour builder l’application.
+Vous pouvez lancer la commande `npm run build` pour compiler l’application.

 ```bash
 $ npm run build
 ```

-Par défaut, la sortie du build sera placée dans `dist`. Vous pouvez déployer ce dossier `dist` à l’aide de la plateforme de votre choix.
+Par défaut, la sortie de compilation sera placée dans `dist`. Vous pouvez déployer ce dossier `dist` à l’aide de la plateforme de votre choix.

 ### Tester l’application localement

-Une fois que vous avez buildé l’application, vous pouvez la tester localement avec la commande `npm run preview`.
+Une fois que vous avez compilé l’application, vous pouvez la tester localement avec la commande `npm run preview`.

 ```bash
 $ npm run build
 $ npm run preview
 ```

-La commande `vite preview` va démarrer un serveur web statique local qui sert les fichiers du dossier `dist` sur `http://localhost:4173`. C’est un moyen facile de vérifier que le build de production fonctionne en local.
+La commande `vite preview` va démarrer un serveur web statique local qui sert les fichiers du dossier `dist` sur `http://localhost:4173`. C’est un moyen facile de vérifier que la compilation de production fonctionne en local.

 Vous pouvez configurer le port du serveur en passant l’option `--port` comme argument.

 ```json
@@ -69,12 +69,12 @@

    # annuler s’il y a une erreur
    set -e

-   # build
+   # compilation
    npm run build

-   # naviguer au répertoire de sortie du build
+   # naviguer au répertoire de sortie de compilation
    cd dist

    # si vous déployez vers un domaine personnalisé
    # echo 'www.example.com' > CNAME
@@ -138,9 +138,9 @@
    Si vous déployez sur `https://<NOM D’UTILISATEUR ou GROUPE>.gitlab.io/`, vous pouvez omettre `base` puisque la valeur par défaut est `'/'`.

    Si vous dépolyez sur `https://<NOM D’UTILISATEUR ou GROUPE>.gitlab.io/<DÉPÔT>/`, par exemple si l’adresse de votre dépôt est `https://gitlab.com/<NOM D’UTILISATEUR>/<DÉPÔT>`, alors définissez `base` à `'/<DÉPÔT>/'`.

-2. Créez un fichier nommé `.gitlab-ci.yml` à la racine de votre projet avec le contenu ci-dessous. Cela va builder et déployer votre site chaque fois que vous en modifiez le contenu :
+2. Créez un fichier nommé `.gitlab-ci.yml` à la racine de votre projet avec le contenu ci-dessous. Cela va compiler et déployer votre site chaque fois que vous en modifiez le contenu :

    ```yaml
    image: node:16.5.0
    pages:
@@ -315,7 +315,7 @@
 - De l’[extension SWA](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurestaticwebapps) pour [Visual Studio Code](https://code.visualstudio.com).

 Installez l’extension sur VS Code et naviguez à la racine de votre application. Ouvrez l’extension, connectez-vous à Azure, et cliquez sur le signe « + » pour créer une nouvelle Static Web App. On vous demandera quelle clé de souscription utiliser.

-Suivez les instructions de l’extension pour donner un nom à votre application, choisissez un preset de framework, et donnez la racine de l’application (le plus souvent `/`) ainsi que l’emplacement des fichiers buildés `/dist`. Une action GitHub sera créée dans votre dépôt dans un dossier `.github`.
+Suivez les instructions de l’extension pour donner un nom à votre application, choisissez un preset de framework, et donnez la racine de l’application (le plus souvent `/`) ainsi que l’emplacement des fichiers compilés `/dist`. Une action GitHub sera créée dans votre dépôt dans un dossier `.github`.

 L’action déploiera votre application (vous pouvez suivre la progression dans l’onglet Actions de votre dépôt) et, lorsque le process réussit, vous permettra de voir votre application à l’adresse fournie en cliquant sur le bouton « Browse Website » de la fenêtre de progression de l’extension, qui apparaît une fois que l’action GitHub s’est exécutée.
diff --git a/guide/using-plugins.md b/guide/using-plugins.md
--- guide/using-plugins.md
+++ guide/using-plugins.md
@@ -39,13 +39,13 @@
 Vous pouvez également trouver les plugins qui suivent les [conventions recommandées](./api-plugin.md#conventions) en faisant une [recherche npm de vite-plugin](https://www.npmjs.com/search?q=vite-plugin&ranking=popularity) pour les plugins Vite ou une [recherche npm de rollup-plugin](https://www.npmjs.com/search?q=rollup-plugin&ranking=popularity) pour les plugins Rollup.

 ## Forcer l’ordre des plugins

-Pour assurer la compatibilité avec certains plugins Rollup, il est possible qu’il soit nécessaire de forcer l’ordre d’un plugin ou de seulement l’appliquer pour le build. Cela devrait être un détail d’implémentation des plugins Vite. Vous pouvez forcer la position d’un plugin avec le modifieur `enforce` :
+Pour assurer la compatibilité avec certains plugins Rollup, il est possible qu’il soit nécessaire de forcer l’ordre d’un plugin ou de seulement l’appliquer pour la compilation. Cela devrait être un détail d’implémentation des plugins Vite. Vous pouvez forcer la position d’un plugin avec le modifieur `enforce` :

 - `pre` : invoque le plugin avant les plugins du noyau de Vite
 - par défaut : invoque le plugin après les plugins du noyau de Vite
-- `post` : invoque le plugin après les plugins de build de Vite
+- `post` : invoque le plugin après les plugins de compilation de Vite

 ```js
 // vite.config.js
 import image from '@rollup/plugin-image'
@@ -64,9 +64,9 @@
 Allez voir le [Guide de l’API pour plugin](./api-plugin.md#ordre-du-plugin) pour de plus amples informations, et soyez attentifs à l’indication `enforce` ainsi qu’aux instructions d’utilisation pour les plugins populaires dans la liste de compatibilité [Vite Rollup Plugins](https://vite-rollup-plugins.patak.dev).

 ## Application conditionnelle

-Par défaut, les plugins sont invoqués à la fois pour le développement et pour le build. Dans les cas où un plugin doit être appliqué conditionnellement seulement pour le développement ou pour le build, utilisez la propriété `apply` pour l’invoquer seulement durant `'build'` ou `'serve'` :
+Par défaut, les plugins sont invoqués à la fois pour le développement et pour la compilation. Dans les cas où un plugin doit être appliqué conditionnellement seulement pour le développement ou pour la compilation, utilisez la propriété `apply` pour l’invoquer seulement durant `'build'` ou `'serve'` :

 ```js
 // vite.config.js
 import typescript2 from 'rollup-plugin-typescript2'
diff --git a/guide/why.md b/guide/why.md
--- guide/why.md
+++ guide/why.md
@@ -11,9 +11,9 @@
 Vite a pour but de régler ces problèmes en s’appuyant sur les dernières avancées de l’écosystème : la possibilité d’utiliser des modules ES natifs dans le navigateur, et l’apparition d’outils JavaScripts écrits à l’aide de langages compilés.

 ### Démarrage lent du serveur

-Lorsque vous démarrez le serveur de développement à froid, si votre configuration de build est basée sur un bundler, il doit rapidement crawler puis builder toute votre application avant qu’elle ne puisse être servie.
+Lorsque vous démarrez le serveur de développement à froid, si votre configuration de compilation est basée sur un bundler, il doit rapidement crawler puis compiler toute votre application avant qu’elle ne puisse être servie.

 Vite raccourcit la durée du démarrage du serveur en divisant d’abord les modules d’une application en deux catégories : les **dépendances** et le **code source**.

 - Les **dépendances** consistent le plus souvent en du JavaScript qui ne change pas pendant le développement. Certaines dépendances d’une taille conséquente (par exemple les librairies de composants comportant des centaines de modules) sont aussi relativement coûteuses à traiter.
@@ -29,9 +29,9 @@
   ![esm based dev server](/images/esm.png)

 ### Rafraîchissement lent

-Quand un fichier est édité dans le contexte d’une configuration de build basée sur un bundler, il est inefficace de refaire le build de zéro, pour des raisons évidentes : la durée de rafraîchissement va augmenter linéairement en fonction de la taille de l’application.
+Quand un fichier est édité dans le contexte d’une configuration de compilation basée sur un bundler, il est inefficace de refaire la compilation de zéro, pour des raisons évidentes : la durée de rafraîchissement va augmenter linéairement en fonction de la taille de l’application.

 Certains serveurs de développement de bundlers gardent leurs opérations en mémoire, et peuvent ainsi invalider seulement une certaine partie du graphe des modules lorsqu’un fichier est modifié, mais il y a toujours besoin de reconstruire l’intégralité du bundle et de recharger la page web. Reconstruire le bundle est coûteux, et recharger la page ne permet pas de conserver l’état de l’application. C’est la raison pour laquelle certains bundlers supportent le remplacement de modules à la volée (_hot module replacement_ ou _HMR_) : cela permet de rafraîchir un module « à chaud », sans affecter le reste de la page. Cela améliore grandement l’expérience de développement – cependant, en pratique nous avons remarqué que même la vitesse des mises à jour à la volée se détériore nettement en fonction de la taille de l’application.

 Avec Vite, le remplacement des modules à la volée est effectué à travers les modules ES natifs. Quand un fichier est édité, Vite peut invalider seulement précisément le module correspondant ainsi que le code environnant s’il y lieu, ce qui permet de rendre le rafraîchissement à la volée rapide en toutes circonstances, peu importe la taille de votre application.
@@ -43,13 +43,13 @@
 ## Pourquoi faire un bundle de production ?

 Même si les modules ES natifs sont désormais largement supportés, les utiliser en production sans bundling reste inefficace (même avec HTTP/2) à cause des allers-retours causés par les imports imbriqués. Pour obtenir une meilleure performance de chargement en production, il reste plus efficace de bundler votre code en éliminant le code inutile (_tree-shaking_), en usant du chargement opportun (_lazy loading_) et du fractionnement en morceaux (_common chunk splitting_) (qui permet de favoriser la mise en cache).

-Il n’est pas simple de concilier le fait de rendre un build optimisé et d’assurer que le comportement en développement et en production soit cohérent. C’est la raison pour laquelle Vite fournit une [commande de build](./build) qui inclut d’origine de nombreuses [optimisations de performance](./features#optimisations-du-build).
+Il n’est pas simple de concilier le fait de rendre une compilation optimisée et d’assurer que le comportement en développement et en production soit cohérent. C’est la raison pour laquelle Vite fournit une [commande de compilation](./build) qui inclut d’origine de nombreuses [optimisations de performance](./features#optimisations-de-la-compilation).

 ## Pourquoi ne pas utiliser esbuild pour le bundle ?

-Bien qu’`esbuild` soit très rapide et soit déjà capable de bundler des librairies, certaines fonctionnalités nécessaires pour le bundle d’_applications_ sont toujours en cours de développement — en particulier le fractionnement du code et la gestion du CSS. Pour le moment, Rollup est plus mature et flexible à ces égards. Ceci dit, nous n’excluons pas d’utiliser `esbuild` pour le build de production une fois que ces sujets seront traités.
+Bien qu’`esbuild` soit très rapide et soit déjà capable de bundler des librairies, certaines fonctionnalités nécessaires pour le bundle d’_applications_ sont toujours en cours de développement — en particulier le fractionnement du code et la gestion du CSS. Pour le moment, Rollup est plus mature et flexible à ces égards. Ceci dit, nous n’excluons pas d’utiliser `esbuild` pour la compilation de production une fois que ces sujets seront traités.

 ## En quoi Vite diffère-t-il de … ?

 Vous pouvez vous rendre à la [section Comparaisons](./comparisons) pour plus de détails sur la façon dont Vite diffère des autres outils similaires.
